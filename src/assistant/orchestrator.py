import logging
import asyncio
from typing import Optional, Dict, Any, List, Union
import pydantic
from pydantic import TypeAdapter

from src.assistant.models.actions import ClickAction, TypeTextAction, OpenApplicationAction, NavigateWebsiteAction, TakeScreenshotAction, AnalyzeScreenshotAction, TaskCompleteAction, TaskFailedAction, DoubleClickAction, AnyAction, ScrollAction, PressKeyAction, MoveMouseAction, WaitAction, FindAppAction
from src.assistant.interfaces.llm_service import LLMService
from src.assistant.interfaces.vlm_service import VLMService
from src.assistant.interfaces.desktop_controller import IDesktopController
from src.assistant.models.actions import AnyAction
from src.assistant.models.common import BoundingBox, VLMAnalysisResult, Coordinates
from src.assistant.exceptions import OrchestrationError, LLMError, VLMError, DesktopControlError, ScreenshotError

logger = logging.getLogger(__name__)


class Orchestrator:
    """
    Coordinates the execution of a plan generated by an LLM, using VLM for
    visual analysis and DesktopController for GUI interaction.
    """

    def __init__(
        self,
        llm_service: LLMService,
        vlm_service: VLMService,
        desktop_controller: IDesktopController
    ):
        """
        Initializes the Orchestrator.

        Args:
            llm_service: An instance conforming to the LLMService interface.
            vlm_service: An instance conforming to the VLMService interface.
            desktop_controller: An instance conforming to the IDesktopController interface.
        """
        self.llm_service = llm_service
        self.vlm_service = vlm_service
        self.desktop_controller = desktop_controller

        # State variables to hold results between steps
        self._last_screenshot_bytes: Optional[bytes] = None
        self._last_vlm_raw_result: Optional[Dict[str, Any]] = None
        self._last_vlm_parsed_result: Optional[VLMAnalysisResult] = None
        # Keep track of executed actions and results
        self._action_history: List[Dict[str, Any]] = []

        logger.info("Orchestrator initialized.")

    def _clear_state(self):
        """Resets the state before running a new command."""
        self._last_screenshot_bytes = None
        self._last_vlm_raw_result = None
        self._last_vlm_parsed_result = None
        self._action_history = []
        logger.debug("Orchestrator state cleared.")

    def _get_coordinates_from_action_or_vlm(
        self,
        # Accept specific action types that might contain coordinates
        action: Union[ClickAction],
        vlm_result: Optional[Dict[str, Any]]
    ) -> Optional[Coordinates]:
        """
        Attempts to get click/target coordinates for an action.
        Priority:
        1. Explicit 'x', 'y' attributes on the action model instance.
        2. Bounding box found in the last VLM result.

        Args:
            action: The specific Pydantic action model instance (e.g., ClickAction).
            vlm_result: The raw dictionary result from the last VLM analysis.

        Returns:
            A Coordinates object if coordinates are found, otherwise None.
        """
        logger.debug(
            f"Attempting to determine coordinates for action: {action.action}")

        # 1. Check explicit attributes on the action model
        # Ensure the action object *can* have x/y (primarily ClickAction, MoveMouseAction)
        if hasattr(action, 'x') and hasattr(action, 'y') and action.x is not None and action.y is not None:
            try:
                # Pydantic validation should have already ensured these are ints,
                # but a check doesn't hurt if types were Optional[int]
                x = int(action.x)
                y = int(action.y)
                logger.info(
                    f"Using explicit coordinates from action parameters: ({x}, {y})"
                )
                return Coordinates(x=x, y=y)
            except (ValueError, TypeError):
                logger.warning(
                    f"Invalid explicit coordinates ({action.x}, {action.y}) in action, falling back to VLM."
                )

        # Check if the action *intended* to use VLM via description
        # You might have a 'description' field on ClickAction for this purpose
        description_used = hasattr(
            action, 'description') and action.description
        if description_used:
            logger.info(
                f"Action specified description '{action.description}', relying on VLM result.")
        elif hasattr(action, 'x') and action.x is None:  # Explicitly requested VLM/fallback?
            logger.info(
                "Action had no explicit coordinates, attempting fallback to VLM result.")

        # 2. Check last VLM result for a bounding box
        if vlm_result:
            # This part is the same logic as your original function,
            # searching the vlm_result dictionary.
            bbox_list = None
            if isinstance(vlm_result, dict):
                # Reuse the same extraction logic patterns as before
                if "bounding_box" in vlm_result and isinstance(vlm_result["bounding_box"], list):
                    bbox_list = vlm_result["bounding_box"]
                elif "identified_element_bbox" in vlm_result and isinstance(vlm_result["identified_element_bbox"], list):
                    bbox_list = vlm_result["identified_element_bbox"]
                elif "box" in vlm_result and isinstance(vlm_result["box"], list):
                    bbox_list = vlm_result["box"]
                elif "location" in vlm_result and isinstance(vlm_result["location"], dict) and "bounding_box" in vlm_result["location"]:
                    bbox_list = vlm_result["location"]["bounding_box"]
                elif "found_elements" in vlm_result and isinstance(vlm_result["found_elements"], list) and vlm_result["found_elements"]:
                    first_element = vlm_result["found_elements"][0]
                    if isinstance(first_element, dict) and "bounding_box" in first_element and isinstance(first_element["bounding_box"], list):
                        bbox_list = first_element["bounding_box"]
                # Add more extraction patterns specific to your VLM's output if needed

            if bbox_list and len(bbox_list) == 4:
                try:
                    bbox = BoundingBox.from_list(bbox_list)
                    center_coords = bbox.calculate_center()
                    logger.info(
                        f"Using center coordinates from VLM analysis bounding box {bbox_list}: ({center_coords.x}, {center_coords.y})"
                    )
                    return center_coords
                except (ValueError, TypeError) as e:
                    logger.warning(
                        f"Could not parse bounding box {bbox_list} from VLM result: {e}"
                    )
            else:
                logger.warning(
                    "No suitable bounding box found in the last VLM result."
                )
        else:
            logger.warning(
                "No VLM result available to search for coordinates.")

        # 3. Failed to find coordinates from either source
        logger.error(
            f"Failed to determine coordinates for action {action.action}.")
        return None

    async def _execute_action(self, action: AnyAction) -> Optional[Dict[str, Any]]:
        """
        Executes a single action from the plan using discriminated union typing for type safety.
        
        Args:
            action: The specific action model instance to execute (from AnyAction union).
            
        Returns:
            A dictionary containing relevant result data from the action execution, or None if no result.
            
        Raises:
            DesktopControlError: For desktop interaction failures.
            OrchestrationError: For logical errors in action execution flow.
            VLMError: For visual analysis failures.
            ScreenshotError: For screenshot capture failures.
            NotImplementedError: For unhandled action types (shouldn't occur with complete AnyAction coverage).
            Exception: For unexpected errors (wrapped in OrchestrationError).
        """
        # Get the action type from the model (will be the literal string)
        action_type = action.action
        logger.info(f"Executing Action: {action_type}, Reason: {action.reason or 'No reason provided'}")
        logger.debug(f"Action details: {action.model_dump(exclude={'action', 'reason'})}")
        
        result_data: Optional[Dict[str, Any]] = None
        
        try:
            # --- Screenshot Related Actions ---
            if isinstance(action, TakeScreenshotAction):
                try:
                    self._last_screenshot_bytes = await asyncio.to_thread(self.desktop_controller.take_screenshot)
                    logger.info(f"Screenshot taken ({len(self._last_screenshot_bytes)} bytes).")
                    self._last_vlm_raw_result = None  # Clear previous VLM results
                    self._last_vlm_parsed_result = None
                    result_data = {"screenshot_size": len(self._last_screenshot_bytes)}
                except ScreenshotError as e:
                    logger.error(f"Screenshot capture failed: {e}")
                    raise

            elif isinstance(action, AnalyzeScreenshotAction):
                if self._last_screenshot_bytes is None:
                    logger.error("ANALYZE_SCREENSHOT called with no recent screenshot available.")
                    raise OrchestrationError("Missing preceding TAKE_SCREENSHOT action.")
                
                try:
                    logger.info(f"Analyzing screenshot with prompt: '{action.prompt}'")
                    vlm_result = await self.vlm_service.analyze_image(self._last_screenshot_bytes, action.prompt)
                    self._last_vlm_raw_result = vlm_result
                    
                    try:
                        self._last_vlm_parsed_result = VLMAnalysisResult(raw_output=vlm_result)
                        logger.info("VLM analysis completed successfully.")
                        logger.debug(f"VLM Raw Result: {vlm_result}")
                    except Exception as parse_error:
                        logger.warning(f"Could not parse VLM result: {parse_error}. Storing raw result only.")
                        self._last_vlm_parsed_result = None
                    
                    result_data = {"vlm_raw_output": vlm_result}
                except VLMError as e:
                    logger.error(f"VLM analysis failed: {e}")
                    raise

            # --- Desktop Interaction Actions ---
            elif isinstance(action, ClickAction):
                coords = self._get_coordinates_from_action_or_vlm(action, self._last_vlm_raw_result)
                if coords is None:
                    raise OrchestrationError("Could not determine coordinates for CLICK action.")
                
                try:
                    await asyncio.to_thread(self.desktop_controller.click, coords.x, coords.y)
                    logger.info(f"Click executed at ({coords.x}, {coords.y}).")
                    result_data = {"coordinates": coords.model_dump()}
                except DesktopControlError as e:
                    logger.error(f"Click failed at ({coords.x}, {coords.y}): {e}")
                    raise

            elif isinstance(action, DoubleClickAction):  # Assuming we have this model
                coords = self._get_coordinates_from_action_or_vlm(action, self._last_vlm_raw_result)
                if coords is None:
                    raise OrchestrationError("Could not determine coordinates for DOUBLE_CLICK action.")
                
                try:
                    await asyncio.to_thread(self.desktop_controller.double_click, coords.x, coords.y)
                    logger.info(f"Double click executed at ({coords.x}, {coords.y}).")
                    result_data = {"coordinates": coords.model_dump()}
                except DesktopControlError as e:
                    logger.error(f"Double click failed at ({coords.x}, {coords.y}): {e}")
                    raise

            elif isinstance(action, TypeTextAction):
                try:
                    await asyncio.to_thread(
                        self.desktop_controller.type_text,
                        action.text,
                        interval=action.interval
                    )
                    logger.info(f"Typed text (length: {len(action.text)}).")
                    result_data = {"text_typed": action.text}
                except DesktopControlError as e:
                    logger.error(f"Typing failed: {e}")
                    raise

            elif isinstance(action, MoveMouseAction):
                try:
                    await self.desktop_controller.move_mouse(action.x, action.y, action.duration)
                    result_data = {"x": action.x, "y": action.y}
                except DesktopControlError as e:
                    logger.error(f"Move mouse to ({action.x}, {action.y}) failed: {e}")
                    raise

            elif isinstance(action, PressKeyAction):
                try:
                    await asyncio.to_thread(self.desktop_controller.press_key, action.key_name)
                    logger.info(f"Pressed key: '{action.key_name}'.")
                    result_data = {"key_pressed": action.key_name}
                except DesktopControlError as e:
                    logger.error(f"Key press failed for '{action.key_name}': {e}")
                    raise

            # --- Application Control Actions ---
            elif isinstance(action, OpenApplicationAction):
                try:
                    await self.desktop_controller.open_application(action.application_name)
                    logger.info(f"Opened application: '{action.application_name}'.")
                    result_data = {"application_opened": action.application_name}
                except DesktopControlError as e:
                    logger.error(f"Failed to open application '{action.application_name}': {e}")
                    raise

            elif isinstance(action, NavigateWebsiteAction):
                try:
                    await self.desktop_controller.navigate_url(action.url)
                    logger.info(f"Navigated to URL: '{action.url}'.")
                    result_data = {"url_navigated": action.url}
                except DesktopControlError as e:
                    logger.error(f"Failed to navigate to URL '{action.url}': {e}")
                    raise

            # --- System/Utility Actions ---
            elif isinstance(action, WaitAction):
                try:
                    duration_sec = max(0, action.duration_ms / 1000.0)  # Ensure non-negative
                    logger.info(f"Waiting for {duration_sec:.2f} seconds.")
                    await asyncio.sleep(duration_sec)
                    result_data = {"duration_ms": action.duration_ms}
                except (ValueError, TypeError) as e:
                    logger.warning(f"Invalid duration, defaulting to 1 second. Error: {e}")
                    await asyncio.sleep(1.0)
                    result_data = {"duration_ms": 1000}

            elif isinstance(action, FindAppAction):  # Conceptual action
                logger.info(f"Looking for application: '{action.app_name}'")
                result_data = {"app_name": action.app_name}

            # --- Terminal Actions ---
            elif isinstance(action, TaskCompleteAction):
                logger.info(f"Task marked complete: {action.message or 'No message'}")
                result_data = {"success": True, "message": action.message}

            elif isinstance(action, TaskFailedAction):
                logger.info(f"Task marked failed: {action.message or 'No message'}")
                result_data = {"success": False, "message": action.message}

            elif isinstance(action, ScrollAction):
                try:
                    await self.desktop_controller.scroll(action.direction, action.amount)
                    result_data = {"direction": action.direction, "amount": action.amount}
                except DesktopControlError as e:
                    logger.error(f"Scroll {action.direction} failed: {e}")
                    raise
            # --- Unhandled Action Type ---
            else:
                logger.error(f"Unhandled action type in _execute_action: {type(action)}")
                raise NotImplementedError(f"Execution logic missing for action type: {type(action)}")

            # Update action history with successful execution
            self._action_history.append({
                "action": action.model_dump(),
                "status": "success",
                "result": result_data
            })
            return result_data

        except (DesktopControlError, OrchestrationError, VLMError, ScreenshotError, NotImplementedError) as e:
            # Known error types - log and re-raise (handled in run() method)
            logger.error(f"Error executing action {action_type}: {e}", exc_info=True)
            raise

        except Exception as e:
            # Unexpected error - wrap in OrchestrationError
            logger.exception(f"Unexpected error during {action_type} execution: {e}")
            raise OrchestrationError(f"Unexpected error during {action_type}: {e}") from e

    def _get_coordinates_from_params_or_vlm(
        self, params: Dict[str, Any], vlm_result: Optional[Dict[str, Any]]
    ) -> Optional[Coordinates]:
        """
        Attempts to get click coordinates.
        Priority:
        1. Explicit 'x', 'y' in action parameters.
        2. Bounding box found in the last VLM result.
        """
        # 1. Check explicit parameters
        if "x" in params and "y" in params:
            try:
                x = int(params["x"])
                y = int(params["y"])
                logger.info(
                    f"Using explicit coordinates from parameters: ({x}, {y})")
                return Coordinates(x=x, y=y)
            except (ValueError, TypeError, KeyError):
                logger.warning(
                    "Invalid explicit coordinates in parameters, falling back to VLM.")

        # 2. Check last VLM result for a bounding box
        if vlm_result:
            # Try extracting bbox based on common patterns in VLM output
            bbox_list = None
            if isinstance(vlm_result, dict):
                # Example patterns - ADJUST BASED ON ACTUAL OMNIPARSER OUTPUT STRUCTURE
                if "bounding_box" in vlm_result and isinstance(vlm_result["bounding_box"], list):
                    bbox_list = vlm_result["bounding_box"]
                elif "identified_element_bbox" in vlm_result and isinstance(vlm_result["identified_element_bbox"], list):
                    bbox_list = vlm_result["identified_element_bbox"]
                elif "box" in vlm_result and isinstance(vlm_result["box"], list):
                    bbox_list = vlm_result["box"]
                elif "location" in vlm_result and isinstance(vlm_result["location"], dict) and "bounding_box" in vlm_result["location"]:
                    bbox_list = vlm_result["location"]["bounding_box"]
                # Check within found elements if structure is like that
                elif "found_elements" in vlm_result and isinstance(vlm_result["found_elements"], list) and vlm_result["found_elements"]:
                    # Try the first element's box if available
                    first_element = vlm_result["found_elements"][0]
                    if isinstance(first_element, dict) and "bounding_box" in first_element and isinstance(first_element["bounding_box"], list):
                        bbox_list = first_element["bounding_box"]

            if bbox_list and len(bbox_list) == 4:
                try:
                    bbox = BoundingBox.from_list(bbox_list)
                    center_coords = bbox.calculate_center()
                    logger.info(
                        f"Using center coordinates from last VLM analysis bounding box {bbox_list}: ({center_coords.x}, {center_coords.y})")
                    return center_coords
                except (ValueError, TypeError) as e:
                    logger.warning(
                        f"Could not parse bounding box {bbox_list} from VLM result: {e}")
            else:
                logger.warning(
                    "No suitable bounding box found in the last VLM result.")

        logger.error("Failed to determine coordinates for click/double_click.")
        return None

    async def run(self, command: str):
        """
        Runs the full process: Get plan -> Execute plan step-by-step.

        Args:
            command: The user's natural language command.
        """
        self._clear_state()
        logger.info(f"Received command: '{command}'")

        try:
            # 1. Get Plan from LLM
            logger.info("Generating execution plan...")
            raw_plan = await self.llm_service.generate_plan(command)
            # Validate and parse into Action models
            action_adapter = TypeAdapter(AnyAction)
            # plan: List[AnyAction] = [pydantic.parse_obj_as(AnyAction, step) for step in raw_plan]
            plan: List[AnyAction] = [action_adapter.validate_python(step) for step in raw_plan]
            logger.info(f"Plan received with {len(plan)} steps.")

            # 2. Execute Plan
            for i, action_step in enumerate(plan):
                logger.info(f"--- Step {i + 1}/{len(plan)} ---")
                try:
                    await self._execute_action(action_step)

                    # Check for terminal actions
                    if action_step.action.upper() in ["TASK_COMPLETE", "TASK_FAILED"]:
                        final_message = action_step.parameters.get("message") or action_step.parameters.get(
                            "reason") or f"Task ended with {action_step.action}."
                        success = action_step.parameters.get(
                            "success", action_step.action.upper() == "TASK_COMPLETE")
                        logger.info(
                            f"Execution finished by terminal action. Success: {success}. Message: {final_message}")
                        # User-facing output
                        print(f"\nAssistant: {final_message}")
                        return  # Stop execution
                except (OrchestrationError, LLMError, VLMError, DesktopControlError, ScreenshotError) as e:
                    logger.exception(
                        f"Error during execution of step {i+1} ({action_step.action}): {e}")
                    error_message = f"Execution failed at step {i+1} ({action_step.action}): {e}"
                    # Record failure in history
                    self._action_history.append({
                        "action": action_step.model_dump(),
                        "status": "failed",
                        "error": str(e)
                    })
                    # Optionally try to ask LLM to replan, or just fail
                    # User-facing output
                    print(f"\nAssistant Error: {error_message}")
                    # Add a TASK_FAILED step implicitly
                    await self._execute_action(TaskFailedAction(reason=f"Error occurred: {e}", message=error_message))
                    return  # Stop execution on error
                except Exception as e:  # Catch unexpected errors
                    logger.exception(
                        f"Unexpected error during execution of step {i+1} ({action_step.action}): {e}")
                    error_message = f"Unexpected failure at step {i+1} ({action_step.action}): {e}"
                    self._action_history.append({
                        "action": action_step.model_dump(),
                        "status": "failed",
                        "error": f"Unexpected: {e}"
                    })
                    # User-facing output
                    print(f"\nAssistant Error: {error_message}")
                    await self._execute_action(TaskFailedAction(reason=f"Unexpected error: {e}", message=error_message))
                    return  # Stop execution

                # Small delay between steps might be helpful
                await asyncio.sleep(0.2)  # 200ms pause between actions

            # If loop finishes without a terminal action (shouldn't happen with good plans)
            logger.warning(
                "Plan execution finished without a TASK_COMPLETE or TASK_FAILED action.")
            print(
                "\nAssistant: Task sequence completed, but no explicit final status was given.")

        except (LLMError, pydantic.ValidationError) as e:
            logger.exception(f"Failed to generate or parse plan: {e}")
            print(f"\nAssistant Error: Failed to generate a valid plan. {e}")
        except Exception as e:
            logger.exception(
                f"An unexpected error occurred in the orchestrator run loop: {e}")
            print(f"\nAssistant Error: An unexpected error occurred. {e}")

        finally:
            # Log the full history (optional)
            logger.debug(f"Final action history: {self._action_history}")
